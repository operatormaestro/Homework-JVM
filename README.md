# JvmComprehension
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
## ClassLoader'ы.
В начале последовательно запускаются ClassLoader'ы, для загрузки классов представленных в коде программы. Поскольку подгрузка классов ленивая, она начнется с класса JvmComprehension. Поиск класса начнется с поиска в именованных модулях, определенных для всех встроенных загрузчиков. Application ClassLoader,  делегирует поиск класса на уровень ниже в Platform ClassLoader, который передаст запрос еще ниже по цепочке в Bootstrap ClassLoader. Bootstrap ClassLoader не найдет класс и вернет вызов на этап выше, в Platform ClassLoader который также не найдет класс, и только тогда отработает Application ClassLoader, который подгрузит объявленный класс JvmComprehension.
Далее в строке 2 будет обнаружен класс Object, его подгрузка пойдет по тому же сценарию, но этот класс будет обнаружен и соответственно подгружен Bootstrap ClassLoader. В строке 3 все тоже самое произойдет с классом Inetrger, при выполнении строки 6 будут подгружены классы System и PrintStream(поскольку метод println() является методом класса PrintStream) также в Bootstrap ClassLoader.
Далее все загруженные классы пройдут последовательно этап связывания (Linking), включающий в себя проверку (Verify), подготовку (Prepare) и разрешение символьных ссылок (Resolve), далее пройдет инициализация. Все подгруженные классы (имя, методы, поля и прочее) будут записаны в область памяти называемой Metaspace(в принципе если быть более точным JVM загрузит классы Oblect, Integer PrintStream раньше, еще до начала исполнения кода программы, в зависимости от реализации JVM до начала исполнения будут подгружены порядка 2000 классов в том числе и вышеперечисленные, но оставлю описание как есть для большей наглядности).

<kbd>
<image src="/images/ScreenShot1.png" alt="ClassLoaders">
</kbd>

## Области памяти
Программа начинает выполняться с точки входа которой является метод main(String[] args), в области памяти stack выделяется область именуемая frame для этого метода, все переменные метода будут видны исключительно в рамках этой области.
В строке 1 создается примитивная переменная типа int, ей присваевается значение 1, далее эта переменная, уже проинициализированнная помещается в stack, поскольку примитивы хранятся непосредственно в стеке.
В строке 2 создается объект класса Object, для начала выполняется операнды справа от знака "=", отрабатывет конструктор класса, выделяется необходимый объем памяти в области памяти называемой heap(куча). Затем отрабатывают операнды слева, в стеке создается переменная о, в которой храниться указательн на созданный на предидущем этапе в куче объект.
В 3 строке создается объект класса Integer. Поскольку Integer является классом оберткой для примитивного типа int, в куче будет выделена область памяти необходимая для хранения объекта класса Integer, в том числе и присвоенное значение 2 (в поле  private final int value), после чего в стеке в фрейме main, будет создана ссылочная переменная хранящая адрес созданного на предидущем этапе в куче объекта.
В строке 4 кода вызывается метод printAll, для него создается новый frame и в него в качестве аргументов передаются значение ссылочной переменной  o (адрес который хранит о копируется в новую, созданную в стеке переменную и таким образом указывает на уже созданный ранее в строке 2 объект хранящийся в куче), значение переменной ii (происходит тоже самое что и с о), создается в стеке же примитив i, значение так же копируется, таким образом в куче ничего не происходит, в новом фрейме созданы переменные и скопированы ссылки и данные.
В строке 5 создается ссылочная переменная типа Integer, все повторяется как в строке 3, только value присваивается значение 700. 
В строке 6 вызывается метод println() внутри которого вызывается метод toString() (там вызывается цепочкой множество методов типа getName(), getClass() и т. д.) который возвращает строку, далее происходит конкатенация полученной строки со значениями переменных i и ii (метод toString() вызывается для обеих переменных не явно), далее вызывается метод println() для статического поля out класса System, который отвечает за вывод преданной в качестве аргумента строки на консоль.
В строке 7 в куче создается значение типа String «finish» и также вызывается метод println().

<kbd>
<<<<<<< HEAD
<image src="/images/ScreenShot2.png" alt="Stack&Heap">
=======
<<<<<<< HEAD
<image src="/images/ScreenShot2.png" alt="Stack&Heap">
=======
<image src="/images/ScreenShot2.jpg" alt="Stack&Heap">
>>>>>>> 351bff9 (Final version)
>>>>>>> a46367b (Final version)
</kbd>